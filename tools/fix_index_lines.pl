#!/usr/bin/env perl
# Reads UMR file generated by Federica's converter from UD. Re-computes all
# Index lines based on corresponding Words lines so that left margin of each
# index aligns with the left margin of the corresponding word, and no indices
# are glued together.
# Copyright Â© 2025 Dan Zeman <zeman@ufal.mff.cuni.cz>
# License: GNU GPL

use utf8;
use open ':utf8';
binmode(STDIN, ':utf8');
binmode(STDOUT, ':utf8');
binmode(STDERR, ':utf8');

my $indexline;
my $wordline;
while(<>)
{
    if(m/^Index:/)
    {
        # Save the line but do not print anything yet.
        $indexline = $_;
    }
    elsif(m/^Words:/)
    {
        # This line is expected immediately after an Index line. Check it.
        if(defined($indexline))
        {
            $wordline = $_;
            $wordline =~ s/^Words:\s*//;
            $wordline =~ s/\s*\r?\n$//;
            my @words = split(/\s+/, $wordline);
            my @indices;
            for(my $i = 0; $i <= $#words; $i++)
            {
                my $index = $i+1;
                my $lw = length($words[$i]);
                my $li = length($index);
                if($li > $lw)
                {
                    $words[$i] .= ' ' x ($li-$lw);
                }
                elsif($lw > $li)
                {
                    $index .= ' ' x ($lw-$li);
                }
                push(@indices, $index);
            }
            print("Index: ", join(' ', @indices), "\n");
            print("Words: ", join(' ', @words), "\n");
        }
        else
        {
            die("Words line not immediately preceded by an Index line");
        }
        $indexline = undef;
        $wordline = undef;
    }
    else
    {
        # Pass all other lines simply through.
        print;
        $indexline = undef;
        $wordline = undef;
    }
}
